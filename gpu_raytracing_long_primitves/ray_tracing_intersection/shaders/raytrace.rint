#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"
#include "wavefront.glsl"


layout(binding = 7, set = 1, scalar) buffer allSpheres_
{
  Sphere allSpheres[];
};

layout(binding = 8, set = 1, scalar, std140) buffer allBeziers_
{
  Bezier allBeziers[];
};

layout(binding = 9, set = 1, scalar, std140) buffer allHairs_
{
  Hair allHairs[];
};


struct Ray
{
  vec3 origin;
  vec3 direction;
};

// Ray-Sphere intersection
// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/
float hitSphere(const Sphere s, const Ray r)
{
  vec3  oc           = r.origin - s.center;
  float a            = dot(r.direction, r.direction);
  float b            = 2.0 * dot(oc, r.direction);
  float c            = dot(oc, oc) - s.radius * s.radius;
  float discriminant = b * b - 4 * a * c;
  if(discriminant < 0)
  {
    return 10000;
  }
  else
  {
    return (-b - sqrt(discriminant)) / (2.0 * a);
  }
}

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);
  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : 10000;
}

// ray-box intersection (simplified)
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) 
{
	// ray-box intersection in box space
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-cen);
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec2(-1.0);

	return vec2( tN, tF );
}

float length2( in vec3 v ) { return dot(v,v); }

vec3 iSegment( const Ray r, in vec3 a, in vec3 b )
{
	vec3 ba = b - a;
	vec3 oa = r.origin - a;
	
	float oad  = dot( oa, r.direction );
	float dba  = dot( r.direction, ba );
	float baba = dot( ba, ba );
	float oaba = dot( oa, ba );
	
	vec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);
	
	th.x = max(   th.x, 0.0 );
	th.y = clamp( th.y, 0.0, 1.0 );
	
	vec3 p =  a + ba*th.y;
	vec3 q = r.origin + r.direction * th.x;
	
	return vec3( th, length2( p-q ) );
    
}


float iBezier(const Ray r, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float width)
{
//return 1.0;
#if 0
	Sphere s0 = {p0, 1.0};
	Sphere s1 = {p1, 1.0};
	Sphere s2 = {p2, 1.0};
	Sphere s3 = {p3, 1.0};
	float t0 = hitSphere(s0, r);
	float t1 = hitSphere(s1, r); 
	float t2 = hitSphere(s2, r);
	float t3 = hitSphere(s3, r);
	float t = 10000;
	t = min(t0, t);
	t = min(t1, t);
	t = min(t2, t);
	t = min(t3, t);
	return t;
#endif

    const int kNum = 50;
    
    float hit = -1.0;
    float res = 1e10;
    vec3 a = p0;
    for( int i=1; i<kNum; i++ )
    {
        float t = float(i)/float(kNum-1);
        float s = 1.0-t;
        vec3 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;
        vec3 r = iSegment( r, a, b );
        if( r.z<width*width )
        {
            res = min( res, r.x );
            hit = 1.0;
        }
        a = b;
    }
    if (hit < 0)
	{
    return 10000.0;
	}
	else
	{
	return res*hit;
	}
}

float iHair(Ray r, in vec3 p0, in vec3 p1, float thickness)
{
// center the cylinder, normalize axis
    vec3 cc = 0.5*(p0 + p1);
    float ch = length(p1 - p0);
    vec3 ca = (p1 - p0)/ch;
    ch *= 0.5;

    vec3  oc = r.origin - cc;

    float card = dot(ca,r.direction);
    float caoc = dot(ca,oc);
    
    float a = 1.0 - card*card;
    float b = dot( oc, r.direction) - caoc*card;
    float c = dot( oc, oc) - caoc*caoc - (thickness/2)*(thickness/2);
    float h = b*b - a*c;
    if( h<0.0 ) return 10000.0;
    h = sqrt(h);
    float t1 = (-b-h)/a;
    //float t2 = (-b+h)/a; // exit point

    float y = caoc + t1*card;

    // body
    if( abs(y)<ch ) return t1;
    
    // caps
    float sy = sign(y);
    float tp = (sy*ch - caoc)/card;
    if( abs(b+a*tp)<h )
    {
        return  tp;
    }

    return 10000.0;
}

void main()
{
  Ray ray;
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;

  // Sphere data
  Sphere sphere = allSpheres[gl_PrimitiveID];
  Bezier bezier = allBeziers[0];

  float tHit    = -1;
  int   hitKind = gl_PrimitiveID % 2 == 0 ? KIND_SPHERE : KIND_CUBE;
  if(true || hitKind == KIND_SPHERE)
  {
    // Sphere intersection
    tHit = hitSphere(sphere, ray);
  } 
  else
  {
    // AABB intersection
    Aabb aabb;
    aabb.minimum = sphere.center - vec3(sphere.radius);
    aabb.maximum = sphere.center + vec3(sphere.radius);
    tHit         = hitAabb(aabb, ray);
  }
  
  float tHitB = 10000.0;
  #if 0
  tHitB = iBezier(ray, bezier.p0, bezier.p1, bezier.p2, bezier.p3, bezier.thickness);
  Sphere s1 = {vec3(bezier.p1.x, bezier.p1.x, bezier.p1.x), 1.0}; 
  //float tHitB = hitSphere(s1, ray);
  if (tHit > 0)
  {
	if (tHitB > 0)
	{
		tHitB = min(tHit, tHitB);
	}
	else
	{
		tHitB = tHit;
	}
  }
  #endif
  #if 0
  for (int i = 0; i < 8000; i++)
  {
  Hair hair = allHairs[i];
  float tempHit = iHair(ray, hair.p0, hair.p1, hair.thickness);
    tHitB = min(tempHit, tHitB);
	}
	#else
	Hair hair = allHairs[gl_PrimitiveID];
	tHitB = iHair(ray, hair.p0, hair.p1, hair.thickness);
	#endif
  // Report hit point
  if(tHitB < 9999)
    reportIntersectionEXT(tHitB, KIND_BEZIER);
}
