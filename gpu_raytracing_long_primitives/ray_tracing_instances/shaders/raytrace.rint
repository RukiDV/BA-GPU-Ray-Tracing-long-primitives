#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"
#include "wavefront.glsl"


layout(binding = 3, set = 1, scalar, std140) buffer allHairs_
{
    Hair allHairs[];
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};


float iHair(Ray r, in mat4 trans, float thickness)
{
    vec4 hom_p0 = trans * vec4(0.0, 0.0, 0.0, 1.0);
    vec3 p0 = vec3(hom_p0 / hom_p0.w);
    vec4 hom_p1 = trans * vec4(0.0, 1.0, 0.0, 1.0);
    vec3 p1 = vec3(hom_p1 / hom_p1.w);
    // center the cylinder, normalize axis
    vec3 cc = 0.5*(p0 + p1);
    float ch = length(p1 - p0);
    vec3 ca = (p1 - p0)/ch;
    ch *= 0.5;

    vec3  oc = r.origin - cc;

    float card = dot(ca, r.direction);
    float caoc = dot(ca, oc);

    float a = 1.0 - card*card;
    float b = dot(oc, r.direction) - caoc*card;
    float c = dot(oc, oc) - caoc*caoc - (thickness)*(thickness);
    float h = b*b - a*c;
    if (h<0.0) return 10000.0;
    h = sqrt(h);
    float t1 = (-b-h)/a;
    //float t2 = (-b+h)/a; // exit point

    float y = caoc + t1*card;

    // body
    if (abs(y)<ch) return t1;

    // caps
    float sy = sign(y);
    float tp = (sy*ch - caoc)/card;
    if (abs(b+a*tp)<h)
    {
        return tp;
    }

    return 10000.0;
}

void main()
{
    Ray ray;
    ray.origin    = gl_WorldRayOriginEXT;
    ray.direction = gl_WorldRayDirectionEXT;

    float tHitB = 10000.0;
    Hair hair = allHairs[gl_InstanceID];
    tHitB = iHair(ray, hair.trans, hair.thickness);

  // Report hit point
//  if(tHitB < 9999)
    reportIntersectionEXT(tHitB, KIND_HAIR);
}
